{"ast":null,"code":"// Detect either spaces or tabs but not both to properly handle tabs for indentation and spaces for alignment\nconst INDENT_REGEX = /^(?:( )+|\\t+)/;\nconst INDENT_TYPE_SPACE = 'space';\nconst INDENT_TYPE_TAB = 'tab';\n/**\nMake a Map that counts how many indents/unindents have occurred for a given size and how many lines follow a given indentation.\n\nThe key is a concatenation of the indentation type (s = space and t = tab) and the size of the indents/unindents.\n\n```\nindents = {\n\tt3: [1, 0],\n\tt4: [1, 5],\n\ts5: [1, 0],\n\ts12: [1, 0],\n}\n```\n*/\n\nfunction makeIndentsMap(string, ignoreSingleSpaces) {\n  const indents = new Map(); // Remember the size of previous line's indentation\n\n  let previousSize = 0;\n  let previousIndentType; // Indents key (ident type + size of the indents/unindents)\n\n  let key;\n\n  for (const line of string.split(/\\n/g)) {\n    if (!line) {\n      // Ignore empty lines\n      continue;\n    }\n\n    let indent;\n    let indentType;\n    let use;\n    let weight;\n    let entry;\n    const matches = line.match(INDENT_REGEX);\n\n    if (matches === null) {\n      previousSize = 0;\n      previousIndentType = '';\n    } else {\n      indent = matches[0].length;\n      indentType = matches[1] ? INDENT_TYPE_SPACE : INDENT_TYPE_TAB; // Ignore single space unless it's the only indent detected to prevent common false positives\n\n      if (ignoreSingleSpaces && indentType === INDENT_TYPE_SPACE && indent === 1) {\n        continue;\n      }\n\n      if (indentType !== previousIndentType) {\n        previousSize = 0;\n      }\n\n      previousIndentType = indentType;\n      use = 1;\n      weight = 0;\n      const indentDifference = indent - previousSize;\n      previousSize = indent; // Previous line have same indent?\n\n      if (indentDifference === 0) {\n        // Not a new \"use\" of the current indent:\n        use = 0; // But do add a bit to it for breaking ties:\n\n        weight = 1; // We use the key from previous loop\n      } else {\n        const absoluteIndentDifference = indentDifference > 0 ? indentDifference : -indentDifference;\n        key = encodeIndentsKey(indentType, absoluteIndentDifference);\n      } // Update the stats\n\n\n      entry = indents.get(key);\n      entry = entry === undefined ? [1, 0] : [entry[0] + use, entry[1] + weight];\n      indents.set(key, entry);\n    }\n  }\n\n  return indents;\n} // Encode the indent type and amount as a string (e.g. 's4') for use as a compound key in the indents Map.\n\n\nfunction encodeIndentsKey(indentType, indentAmount) {\n  const typeCharacter = indentType === INDENT_TYPE_SPACE ? 's' : 't';\n  return typeCharacter + String(indentAmount);\n} // Extract the indent type and amount from a key of the indents Map.\n\n\nfunction decodeIndentsKey(indentsKey) {\n  const keyHasTypeSpace = indentsKey[0] === 's';\n  const type = keyHasTypeSpace ? INDENT_TYPE_SPACE : INDENT_TYPE_TAB;\n  const amount = Number(indentsKey.slice(1));\n  return {\n    type,\n    amount\n  };\n} // Return the key (e.g. 's4') from the indents Map that represents the most common indent,\n// or return undefined if there are no indents.\n\n\nfunction getMostUsedKey(indents) {\n  let result;\n  let maxUsed = 0;\n  let maxWeight = 0;\n\n  for (const [key, [usedCount, weight]] of indents) {\n    if (usedCount > maxUsed || usedCount === maxUsed && weight > maxWeight) {\n      maxUsed = usedCount;\n      maxWeight = weight;\n      result = key;\n    }\n  }\n\n  return result;\n}\n\nfunction makeIndentString(type, amount) {\n  const indentCharacter = type === INDENT_TYPE_SPACE ? ' ' : '\\t';\n  return indentCharacter.repeat(amount);\n}\n\nexport default function detectIndent(string) {\n  if (typeof string !== 'string') {\n    throw new TypeError('Expected a string');\n  } // Identify indents while skipping single space indents to avoid common edge cases (e.g. code comments)\n  // If no indents are identified, run again and include all indents for comprehensive detection\n\n\n  let indents = makeIndentsMap(string, true);\n\n  if (indents.size === 0) {\n    indents = makeIndentsMap(string, false);\n  }\n\n  const keyOfMostUsedIndent = getMostUsedKey(indents);\n  let type;\n  let amount = 0;\n  let indent = '';\n\n  if (keyOfMostUsedIndent !== undefined) {\n    ({\n      type,\n      amount\n    } = decodeIndentsKey(keyOfMostUsedIndent));\n    indent = makeIndentString(type, amount);\n  }\n\n  return {\n    amount,\n    type,\n    indent\n  };\n}","map":{"version":3,"names":["INDENT_REGEX","INDENT_TYPE_SPACE","INDENT_TYPE_TAB","makeIndentsMap","string","ignoreSingleSpaces","indents","Map","previousSize","previousIndentType","key","line","split","indent","indentType","use","weight","entry","matches","match","length","indentDifference","absoluteIndentDifference","encodeIndentsKey","get","undefined","set","indentAmount","typeCharacter","String","decodeIndentsKey","indentsKey","keyHasTypeSpace","type","amount","Number","slice","getMostUsedKey","result","maxUsed","maxWeight","usedCount","makeIndentString","indentCharacter","repeat","detectIndent","TypeError","size","keyOfMostUsedIndent"],"sources":["C:/Users/andyl/AutumnHacks/client/node_modules/detect-indent/index.js"],"sourcesContent":["// Detect either spaces or tabs but not both to properly handle tabs for indentation and spaces for alignment\nconst INDENT_REGEX = /^(?:( )+|\\t+)/;\n\nconst INDENT_TYPE_SPACE = 'space';\nconst INDENT_TYPE_TAB = 'tab';\n\n/**\nMake a Map that counts how many indents/unindents have occurred for a given size and how many lines follow a given indentation.\n\nThe key is a concatenation of the indentation type (s = space and t = tab) and the size of the indents/unindents.\n\n```\nindents = {\n\tt3: [1, 0],\n\tt4: [1, 5],\n\ts5: [1, 0],\n\ts12: [1, 0],\n}\n```\n*/\nfunction makeIndentsMap(string, ignoreSingleSpaces) {\n\tconst indents = new Map();\n\n\t// Remember the size of previous line's indentation\n\tlet previousSize = 0;\n\tlet previousIndentType;\n\n\t// Indents key (ident type + size of the indents/unindents)\n\tlet key;\n\n\tfor (const line of string.split(/\\n/g)) {\n\t\tif (!line) {\n\t\t\t// Ignore empty lines\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet indent;\n\t\tlet indentType;\n\t\tlet use;\n\t\tlet weight;\n\t\tlet entry;\n\t\tconst matches = line.match(INDENT_REGEX);\n\n\t\tif (matches === null) {\n\t\t\tpreviousSize = 0;\n\t\t\tpreviousIndentType = '';\n\t\t} else {\n\t\t\tindent = matches[0].length;\n\t\t\tindentType = matches[1] ? INDENT_TYPE_SPACE : INDENT_TYPE_TAB;\n\n\t\t\t// Ignore single space unless it's the only indent detected to prevent common false positives\n\t\t\tif (ignoreSingleSpaces && indentType === INDENT_TYPE_SPACE && indent === 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (indentType !== previousIndentType) {\n\t\t\t\tpreviousSize = 0;\n\t\t\t}\n\n\t\t\tpreviousIndentType = indentType;\n\n\t\t\tuse = 1;\n\t\t\tweight = 0;\n\n\t\t\tconst indentDifference = indent - previousSize;\n\t\t\tpreviousSize = indent;\n\n\t\t\t// Previous line have same indent?\n\t\t\tif (indentDifference === 0) {\n\t\t\t\t// Not a new \"use\" of the current indent:\n\t\t\t\tuse = 0;\n\t\t\t\t// But do add a bit to it for breaking ties:\n\t\t\t\tweight = 1;\n\t\t\t\t// We use the key from previous loop\n\t\t\t} else {\n\t\t\t\tconst absoluteIndentDifference = indentDifference > 0 ? indentDifference : -indentDifference;\n\t\t\t\tkey = encodeIndentsKey(indentType, absoluteIndentDifference);\n\t\t\t}\n\n\t\t\t// Update the stats\n\t\t\tentry = indents.get(key);\n\t\t\tentry = entry === undefined ? [1, 0] : [entry[0] + use, entry[1] + weight];\n\n\t\t\tindents.set(key, entry);\n\t\t}\n\t}\n\n\treturn indents;\n}\n\n// Encode the indent type and amount as a string (e.g. 's4') for use as a compound key in the indents Map.\nfunction encodeIndentsKey(indentType, indentAmount) {\n\tconst typeCharacter = indentType === INDENT_TYPE_SPACE ? 's' : 't';\n\treturn typeCharacter + String(indentAmount);\n}\n\n// Extract the indent type and amount from a key of the indents Map.\nfunction decodeIndentsKey(indentsKey) {\n\tconst keyHasTypeSpace = indentsKey[0] === 's';\n\tconst type = keyHasTypeSpace ? INDENT_TYPE_SPACE : INDENT_TYPE_TAB;\n\n\tconst amount = Number(indentsKey.slice(1));\n\n\treturn {type, amount};\n}\n\n// Return the key (e.g. 's4') from the indents Map that represents the most common indent,\n// or return undefined if there are no indents.\nfunction getMostUsedKey(indents) {\n\tlet result;\n\tlet maxUsed = 0;\n\tlet maxWeight = 0;\n\n\tfor (const [key, [usedCount, weight]] of indents) {\n\t\tif (usedCount > maxUsed || (usedCount === maxUsed && weight > maxWeight)) {\n\t\t\tmaxUsed = usedCount;\n\t\t\tmaxWeight = weight;\n\t\t\tresult = key;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nfunction makeIndentString(type, amount) {\n\tconst indentCharacter = type === INDENT_TYPE_SPACE ? ' ' : '\\t';\n\treturn indentCharacter.repeat(amount);\n}\n\nexport default function detectIndent(string) {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// Identify indents while skipping single space indents to avoid common edge cases (e.g. code comments)\n\t// If no indents are identified, run again and include all indents for comprehensive detection\n\tlet indents = makeIndentsMap(string, true);\n\tif (indents.size === 0) {\n\t\tindents = makeIndentsMap(string, false);\n\t}\n\n\tconst keyOfMostUsedIndent = getMostUsedKey(indents);\n\n\tlet type;\n\tlet amount = 0;\n\tlet indent = '';\n\n\tif (keyOfMostUsedIndent !== undefined) {\n\t\t({type, amount} = decodeIndentsKey(keyOfMostUsedIndent));\n\t\tindent = makeIndentString(type, amount);\n\t}\n\n\treturn {\n\t\tamount,\n\t\ttype,\n\t\tindent,\n\t};\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}